<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>FOX-style Sports Ticker — Live (ESPN + proxy fallback)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Oswald:wght@600;700&family=Roboto+Condensed:wght@400;700&display=swap" rel="stylesheet">
<style>
  /* ===== ROOT / SIZING (auto scale to viewport height) ===== */
  :root{
    --bar-h: clamp(48px, 7.5vh, 72px);   /* ticker bar height */
    --font-base: calc(var(--bar-h) * 0.42);
    --yellow: #ffd200;
    --scanline-opacity: 0.03;
    --px-per-sec: 110; /* default pacing; will be used in JS calculations */
    --team-glow-strength: 6px;
  }

  html,body{
    height:100%; margin:0; padding:0; background:transparent;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  /* ===== TICKER WRAP (lower third) ===== */
  .ticker-wrap{
    position:fixed; left:0; right:0; bottom:0;
    height:var(--bar-h);
    display:flex; align-items:center;
    padding:6px 14px; box-sizing:border-box;
    background: linear-gradient(to bottom, rgba(25,25,25,0.78), rgba(10,10,10,0.78));
    overflow:hidden;
    transform: translateY(calc(100% + 4px)); /* start hidden (wipe-in) */
    transition: transform 420ms cubic-bezier(.2,.9,.2,1);
  }

  /* show after wipe-in */
  .ticker-wrap.visible{ transform: translateY(0); }

  /* thin FOX yellow accent at top */
  .ticker-wrap::before{
    content:""; position:absolute; left:0; right:0; top:0; height:4px;
    background: linear-gradient(90deg, var(--yellow), color-mix(in srgb,var(--yellow), black 8%));
    z-index:10;
  }

  /* subtle scanline overlay for depth */
  .ticker-wrap::after{
    content:""; position:absolute; inset:0; pointer-events:none;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255,255,255,var(--scanline-opacity)) 0px,
      rgba(255,255,255,var(--scanline-opacity)) 1px,
      rgba(0,0,0,var(--scanline-opacity)) 2px,
      rgba(0,0,0,var(--scanline-opacity)) 3px
    );
    mix-blend-mode: overlay;
    opacity: 0.35;
  }

  /* ===== MOVING RAIL ===== */
  .ticker {
    display:inline-flex; align-items:center;
    white-space:nowrap; will-change:transform;
    font-family: "Oswald", "Roboto Condensed", Arial, Helvetica, sans-serif;
    font-size:var(--font-base);
    color:#fff;
    transform: translateX(100%); /* start offscreen right */
  }

  /* dynamic animation will be applied via JS (name injected) */
  .ticker.animating { animation-timing-function: linear; animation-fill-mode: forwards; }

  /* ===== LEAGUE STINGER (intro) ===== */
  .league {
    display:inline-flex; align-items:center;
    padding:0.35em 0.75em;
    margin-right:0.6em;
    background: rgba(255,255,255,0.06);
    font-weight:700; letter-spacing:0.12em;
    text-transform:uppercase; font-size:0.95em;
    border-radius:3px;
  }

  /* ===== ROUND / EVENT ===== */
  .round {
    display:inline-flex; align-items:center;
    padding:0.25em 0.65em; margin-right:0.6em;
    background: rgba(139,0,0,0.88);
    font-weight:700; text-transform:uppercase; font-size:0.85em;
    border-radius:3px;
  }

  /* ===== GAME BLOCK ===== */
  .game {
    display:inline-flex; align-items:center; gap:0.6em;
    padding:0.28em 0.7em;
    background: rgba(255,255,255,0.04);
    border-radius:3px;
    min-height: calc(var(--bar-h) - 16px);
    box-shadow: inset 0 -1px rgba(255,255,255,0.06);
    border-bottom: 3px solid var(--team-color, rgba(255,255,255,0.08));
    transition: box-shadow 220ms;
  }

  /* team grouping */
  .team { display:inline-flex; align-items:center; gap:0.45em; font-weight:700; text-transform:uppercase; }

  .team img { width: calc(var(--bar-h) * 0.35); height: calc(var(--bar-h) * 0.35); object-fit:contain; display:inline-block; }

  /* score area: if special (OT/shootout) use two-line layout */
  .score {
    font-weight:800; font-variant-numeric: tabular-nums; text-align:center;
    display:flex; flex-direction:column; justify-content:center; gap:0.12em;
  }
  .score .top { font-size:1.02em; }
  .score .bottom { font-size:0.71em; opacity:0.9; text-transform:uppercase; }

  /* status + network */
  .status { margin-left:0.4em; font-size:0.78em; opacity:0.92; white-space:nowrap; }

  .status .live-dot { width:10px; height:10px; border-radius:50%; background:var(--yellow); box-shadow:0 0 8px rgba(255,210,0,0.18); display:inline-block; margin-right:6px; vertical-align:middle; }

  /* separator: slanted FOX-look */
  .separator {
    width:14px; height:70%;
    margin: 0 1.0em;
    background: linear-gradient(135deg, transparent 40%, rgba(255,255,255,0.86) 40%, rgba(255,255,255,0.86) 60%, transparent 60%);
    border-radius:2px;
  }

  /* UP NEXT block (future games) */
  .up-next {
    display:inline-flex; align-items:center; gap:0.5em; padding:0.25em 0.6em;
    background: rgba(0,0,0,0.35); border-radius:3px; font-weight:700; text-transform:uppercase;
  }
  .up-next .time { opacity:0.95; font-size:0.92em; }

  /* lower-third wipe-in effect (also used for stinger flash) */
  .wrap-flash {
    position:absolute; inset:0; pointer-events:none; opacity:0; transition:opacity 320ms;
  }
  .wrap-flash.show { opacity: 0.95; mix-blend-mode:screen; }

  /* reduced motion respect */
  @media (prefers-reduced-motion: reduce) {
    .ticker.animating { animation: none !important; transform: translateX(0) !important; }
    .ticker-wrap { transition: none !important; transform: translateY(0) !important; }
  }

  /* small screens adjustments */
  @media (max-width:720px){
    :root { --px-per-sec: 90; }
  }
</style>
</head>
<body>
  <!-- TICKER BAR -->
  <div class="ticker-wrap" id="tickerWrap" aria-live="polite" role="region" aria-label="Sports scores ticker">
    <div class="wrap-flash" id="wrapFlash" aria-hidden="true"></div>
    <div id="ticker" class="ticker" aria-hidden="false"></div>
  </div>

<script>
/* ======================================================
   LIVE FETCH + PROXY LOGIC (preserved and integrated)
   - uses ESPN endpoints; falls back to AllOrigins proxy
   - caches responses briefly
   - groups playoff rounds, dedupes, sorts by PST kickoff
   ====================================================== */

const PAUSE_BETWEEN_LOOPS = 2500;
const CACHE_TTL = 30_000;
const PIXELS_PER_SECOND = (() => {
  const r = getComputedStyle(document.documentElement).getPropertyValue('--px-per-sec');
  return Number(r) || 110;
})();

const leagues = [
  { name: "NFL", url: "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard", color: "#003594" },
  { name: "NBA", url: "https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard", color: "#17408B" },
  { name: "MLB", url: "https://site.api.espn.com/apis/site/v2/sports/baseball/mlb/scoreboard", color: "#002D72" },
  { name: "NHL", url: "https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard", color: "#111111" }
];

function safe(o, p, f = "") {
  try { return p.split(".").reduce((x, k) => (x && x[k] !== undefined ? x[k] : undefined), o) ?? f; } catch { return f; }
}

async function fetchJson(url) {
  try {
    const r = await fetch(url, { cache: "no-store" });
    if (r.ok) return r.json();
  } catch (e) {}
  try {
    const r2 = await fetch("https://api.allorigins.win/raw?url=" + encodeURIComponent(url));
    if (r2.ok) return r2.json();
  } catch (e) {}
  return null;
}

function pstTimestamp(input) {
  try {
    if (!input) return 0;
    const d = new Date(input);
    const local = new Date(d.toLocaleString("en-US", { timeZone: "America/Los_Angeles" }));
    return local.getTime();
  } catch { return 0; }
}

function formatPST(iso) {
  try {
    if (!iso) return "";
    const d = new Date(iso);
    const local = new Date(d.toLocaleString("en-US", { timeZone: "America/Los_Angeles" }));
    return local.toLocaleString("en-US", { month: "numeric", day: "numeric", hour: "numeric", minute: "2-digit", hour12: true }).replace(",", "");
  } catch { return ""; }
}

/* Build list by querying ESPN endpoints and grouping playoff rounds */
let LAST = null, TS = 0;

async function fetchScores() {
  const now = Date.now();
  if (LAST && (now - TS) < CACHE_TTL) {
    startTickerFromList(LAST);
    return;
  }

  const segments = [];
  const playoffGroups = {};

  for (const lg of leagues) {
    try {
      const data = await fetchJson(lg.url);
      if (!data) continue;

      const events = (data.events || []).slice();

      for (const ev of events) {
        const comp = safe(ev, "competitions.0", null);
        if (!comp) continue;

        const away = (comp.competitors || []).find(t => t.homeAway === "away");
        const home = (comp.competitors || []).find(t => t.homeAway === "home");
        if (!away || !home) continue;

        const iso = ev.date || comp.date || "";
        const kickoff = iso ? formatPST(iso) : "";

        const status = safe(comp, "status.type", {});
        const state = safe(status, "state", "");
        const isLive = state === "in";

        const statusText = isLive
          ? "LIVE"
          : (safe(status, "shortDetail", "") || safe(status, "type.text", "") || "");

        /* broadcasts: keep first 3 names if available */
        const broadcasts = safe(comp, "broadcasts", []) || safe(ev, "broadcasts", []) || [];
        let network = "";
        if (Array.isArray(broadcasts) && broadcasts.length) {
          const b = broadcasts.find(b => b.market === "national") || broadcasts[0];
          if (b) {
            if (Array.isArray(b.names)) network = b.names.slice(0, 3).join(", ");
            else if (b.name) network = b.name;
          }
        }

        const leagueColor = lg.color || "#222";
        const awayLogo = safe(away, "team.logo", safe(away, "team.logos.0.href", "")) || "";
        const homeLogo = safe(home, "team.logo", safe(home, "team.logos.0.href", "")) || "";
        const awayAbbr = (safe(away, "team.abbreviation", safe(away, "team.displayName", "")) || "").toUpperCase();
        const homeAbbr = (safe(home, "team.abbreviation", safe(home, "team.displayName", "")) || "").toUpperCase();
        const awayScore = safe(away, "score", "");
        const homeScore = safe(home, "score", "");
        const isPlayoff = safe(ev, "season.type", 0) === 3;
        const round = isPlayoff ? safe(comp, "notes.0.headline", safe(ev, "league.name", "Playoffs")) : "";

        // statusDetail heuristic used for OT / Shootout detection
        const statusDetail = (safe(status, "type.detail", "") || "").toUpperCase();

        const item = {
          league: lg.name,
          leagueColor,
          isPlayoff,
          round,
          iso,
          kickoff,
          network,
          away: { abbr: awayAbbr, logo: awayLogo, score: awayScore },
          home: { abbr: homeAbbr, logo: homeLogo, score: homeScore },
          isLive,
          statusText,
          statusDetail
        };

        if (isPlayoff) {
          playoffGroups[round] = playoffGroups[round] || [];
          playoffGroups[round].push(item);
        } else {
          segments.push(item);
        }
      }
    } catch (err) {
      console.error("fetchScores league error:", lg.name, err);
    }
  }

  // assemble final list: playoff rounds first (sorted by kickoff) then regular
  const finalList = [];

  const rounds = Object.keys(playoffGroups).sort((a, b) => a.localeCompare(b));
  for (const r of rounds) {
    const arr = playoffGroups[r].sort((x, y) => pstTimestamp(x.iso) - pstTimestamp(y.iso));
    finalList.push({ header: r, type: 'roundHeader' });
    finalList.push(...arr);
  }

  const regularSorted = segments.sort((a, b) => pstTimestamp(a.iso) - pstTimestamp(b.iso));
  if (regularSorted.length) {
    finalList.push({ header: "Regular", type: 'roundHeader' });
    finalList.push(...regularSorted);
  }

  // dedupe by iso|away|home
  const seen = new Set();
  const deduped = [];
  for (const it of finalList) {
    if (it.header) {
      deduped.push(it);
      continue;
    }
    const key = `${it.iso}|${it.away.abbr}|${it.home.abbr}`;
    if (!seen.has(key)) {
      seen.add(key);
      deduped.push(it);
    }
  }

  LAST = deduped;
  TS = Date.now();
  startTickerFromList(deduped);
}

/* ======================================================
   BUILD HTML / RENDERING FUNCTIONS
   - adds league headers
   - adds UP NEXT block for future scheduled games
   - two-line layout when statusDetail indicates OT / SO / SHOOTOUT
   ====================================================== */

function isFutureGame(item) {
  if (!item.iso) return false;
  return pstTimestamp(item.iso) > Date.now() + 60 * 1000; // >1 minute in future
}

function isOvertimeType(item) {
  const d = (item.statusDetail || "").toUpperCase();
  return /OT|OVERTIME|SO|SHOOT|SHOOTOUT/.test(d) || /OT/.test(item.statusText || "");
}

/* Build DOM nodes (safer than innerHTML strings) */
function buildNodeList(list) {
  const nodes = [];
  let lastLeague = null;

  // Optionally build an "UP NEXT" cluster: take next few future games (limit 3)
  const futureGames = list.filter(it => it.type !== 'roundHeader' && isFutureGame(it)).slice(0, 3);
  if (futureGames.length) {
    const upNext = document.createElement('span');
    upNext.className = 'up-next';
    upNext.setAttribute('aria-hidden', 'false');
    const txt = document.createElement('span'); txt.textContent = 'UP NEXT';
    txt.style.fontWeight = '900';
    upNext.appendChild(txt);

    // show first future game's kickoff time
    const tspan = document.createElement('span'); tspan.className = 'time';
    tspan.textContent = futureGames[0].kickoff || '';
    upNext.appendChild(tspan);
    nodes.push(upNext);

    // separator
    const sep = document.createElement('span'); sep.className = 'separator';
    nodes.push(sep);
  }

  // iterate and create league blocks & games
  for (const it of list) {
    if (it.type === 'roundHeader') {
      // round header line
      const r = document.createElement('span');
      r.className = 'round';
      r.textContent = it.header || it;
      nodes.push(r);
      // insert separator
      nodes.push(createSeparator());
      continue;
    }

    // if league changed since last appended league header, add league stinger
    if (it.league && it.league !== lastLeague) {
      const lg = document.createElement('span');
      lg.className = 'league';
      lg.textContent = it.league;
      lg.dataset.league = it.league;
      nodes.push(lg);
      nodes.push(createSeparator());
      lastLeague = it.league;
    }

    // game block
    const g = document.createElement('span');
    g.className = 'game';
    g.style.setProperty('--team-color', chooseTeamColor(it) || 'rgba(255,255,255,0.12)');

    // away team
    const away = document.createElement('span'); away.className = 'team';
    const awayImg = document.createElement('img'); awayImg.className = 'team-logo';
    awayImg.src = it.away.logo || '';
    awayImg.alt = it.away.abbr || '';
    awayImg.onerror = () => { awayImg.style.display = 'none'; };
    away.appendChild(awayImg);
    const awayAb = document.createElement('span'); awayAb.textContent = it.away.abbr || '';
    away.appendChild(awayAb);
    g.appendChild(away);

    // score (two-line if overtime/shootout)
    const score = document.createElement('span'); score.className = 'score';
    const top = document.createElement('span'); top.className = 'top';
    top.textContent = `${it.away.score || '-'} – ${it.home.score || '-'}`;
    score.appendChild(top);
    if (isOvertimeType(it)) {
      const bot = document.createElement('span'); bot.className = 'bottom';
      bot.textContent = (it.statusDetail || it.statusText || '').toUpperCase();
      score.appendChild(bot);
    } else {
      const bot = document.createElement('span'); bot.className = 'bottom';
      bot.textContent = it.kickoff || '';
      if (!it.kickoff && !it.statusText) bot.textContent = it.network || '';
      score.appendChild(bot);
    }
    g.appendChild(score);

    // home team
    const home = document.createElement('span'); home.className = 'team';
    const homeAb = document.createElement('span'); homeAb.textContent = it.home.abbr || '';
    home.appendChild(homeAb);
    const homeImg = document.createElement('img'); homeImg.className = 'team-logo';
    homeImg.src = it.home.logo || '';
    homeImg.alt = it.home.abbr || '';
    homeImg.onerror = () => { homeImg.style.display = 'none'; };
    home.appendChild(homeImg);
    g.appendChild(home);

    // status
    const st = document.createElement('span'); st.className = 'status';
    if (it.isLive) {
      const dot = document.createElement('span'); dot.className = 'live-dot';
      st.appendChild(dot);
      const lt = document.createElement('span'); lt.textContent = (it.statusText || 'LIVE');
      st.appendChild(lt);
    } else {
      st.textContent = (it.statusText || it.kickoff || it.network || '');
    }
    g.appendChild(st);

    nodes.push(g);
    nodes.push(createSeparator());
  }

  return nodes;
}

function chooseTeamColor(it) {
  // prefer home color; fallback to league color
  return it.home && it.home.color ? it.home.color : (it.leagueColor || null);
}

function createSeparator() {
  const s = document.createElement('span'); s.className = 'separator';
  return s;
}

/* ======================================================
   ANIMATION & LOOP CONTROL (true FOX pacing & pause)
   - dynamic keyframes created so scrolling speed is px/sec
   - per-loop league flash & wipe-in
   ====================================================== */

let dynId = 0;
const tickerEl = document.getElementById('ticker');
const wrapEl = document.getElementById('tickerWrap');
const flashEl = document.getElementById('wrapFlash');

function flashLeagueOnce(league) {
  if (!league) return;
  const leagueColor = (leagues.find(l => l.name === league) || {}).color || '#ffffff';
  flashEl.style.background = `linear-gradient(90deg, ${leagueColor}33, ${leagueColor}22)`;
  flashEl.classList.add('show');
  setTimeout(() => flashEl.classList.remove('show'), 420);
}

function wipeInIfNeeded() {
  if (!wrapEl.classList.contains('visible')) {
    wrapEl.classList.add('visible');
  }
}

function startTickerFromList(list) {
  // clear previous animation
  tickerEl.classList.remove('animating');
  tickerEl.style.animationName = '';
  tickerEl.style.animationDuration = '';
  tickerEl.style.transform = 'translateX(100%)';
  tickerEl.innerHTML = '';

  // build nodes
  const nodes = buildNodeList(list);
  for (const n of nodes) tickerEl.appendChild(n);

  // ensure at least one league flash at start (if present)
  const firstLeagueNode = tickerEl.querySelector('.league');
  const leagueName = firstLeagueNode ? firstLeagueNode.dataset.league : null;

  // ensure wipe-in visible
  wipeInIfNeeded();
  flashLeagueOnce(leagueName);

  // measure widths after layout
  void tickerEl.offsetWidth;
  const wrapW = wrapEl.clientWidth;
  const contentW = tickerEl.scrollWidth;

  // UP NEXT handling - if only a few items and contentW small, we still want a short loop
  if (contentW <= wrapW * 1.02) {
    // center and refresh after short pause
    tickerEl.style.transform = 'translateX(0)';
    setTimeout(() => {
      // refresh data and restart
      fetchScores().catch(e => console.error(e));
    }, 6000 + PAUSE_BETWEEN_LOOPS);
    return;
  }

  // compute duration based on pixels-per-second (true FOX pacing)
  const pxPerSec = PIXELS_PER_SECOND || 110;
  const distance = contentW + wrapW;
  const duration = Math.max(6, Math.round((distance / pxPerSec) * 10) / 10); // seconds, one decimal

  // create dynamic keyframes (unique name)
  const name = `ticker_scroll_${++dynId}`;
  const styleId = 'dynamic-ticker-style';
  let styleTag = document.getElementById(styleId);
  if (styleTag) styleTag.remove();

  styleTag = document.createElement('style');
  styleTag.id = styleId;
  styleTag.textContent = `
    @keyframes ${name} {
      from { transform: translateX(${wrapW}px); }
      to   { transform: translateX(${ -contentW }px); }
    }
  `;
  document.head.appendChild(styleTag);

  // apply animation
  tickerEl.classList.add('animating');
  tickerEl.style.animationName = name;
  tickerEl.style.animationDuration = `${duration}s`;
  tickerEl.style.animationTimingFunction = 'linear';

  // when animation ends -> pause -> reset offscreen -> refresh/pause -> restart
  let ended = false;
  function onEnd() {
    if (ended) return;
    ended = true;
    tickerEl.removeEventListener('animationend', onEnd);

    // small pause (FOX-style)
    setTimeout(() => {
      // reset off-screen instantly (remove animation)
      tickerEl.classList.remove('animating');
      tickerEl.style.animationName = '';
      tickerEl.style.transform = 'translateX(100%)';

      // optionally flash league color again before next loop
      if (leagueName) flashLeagueOnce(leagueName);

      // refresh data after small pause, then start again
      setTimeout(() => {
        fetchScores().catch(e => console.error(e));
      }, PAUSE_BETWEEN_LOOPS);
    }, 1800); // pause-on-end in ms (FOX pause)
  }

  tickerEl.addEventListener('animationend', onEnd);
}

/* ======================================================
   BOOTSTRAP + periodic refresh
   ====================================================== */

fetchScores().catch(e => console.error(e));
setInterval(() => fetchScores().catch(e => console.error(e)), 85_000);

/* expose fetchScores for debugging if needed */
window._fetchScoresForTicker = fetchScores;
</script>
</body>
</html>
