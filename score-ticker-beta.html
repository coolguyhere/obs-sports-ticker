<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>ESPN-style Live Ticker (ESPN + proxy, seamless loop, flashes)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />

<style>
  :root{
    --bar-h: clamp(50px, 8vh, 72px);
    --logo-size: calc(var(--bar-h) * 0.6); /* visibly large logos */
    --espn-red: #e31837;
    --pill-bg: rgba(255,255,255,0.08);
    --pill-border: rgba(255,255,255,0.22);
    --target-loop-sec: 36; /* target seconds for a full loop (ESPN-ish) */
  }

  html,body{
    height:100%; margin:0; padding:0; background:transparent; overflow:hidden;
    font-family: "Roboto Condensed", "Arial Narrow", Arial, Helvetica, sans-serif;
    -webkit-font-smoothing:antialiased; -moz-osx-font-smoothing:grayscale;
  }

  /* Ticker container */
  .ticker-wrap{
    position:fixed; left:0; right:0; bottom:0;
    height:var(--bar-h);
    display:flex; align-items:center;
    padding:6px 12px; box-sizing:border-box;
    background: linear-gradient(to bottom, rgba(12,12,12,0.95), rgba(4,4,4,0.95));
    border-top:1px solid rgba(255,255,255,0.04);
    overflow:hidden;
  }

  /* thin ESPN red stripe on top */
  .ticker-wrap::before{
    content:""; position:absolute; left:0; right:0; top:0; height:3px;
    background: linear-gradient(90deg, var(--espn-red), color-mix(in srgb, var(--espn-red), black 6%));
    z-index:10;
  }

  /* the visible viewport; we will translate the .rail for scrolling */
  .rail-viewport{
    width:100%;
    overflow:visible;
  }

  /* rail (will be duplicated for seamless effect) */
  .rail {
    display:inline-flex;
    align-items:center;
    gap:18px;
    white-space:nowrap;
    transform: translateX(0);
    will-change: transform;
  }

  /* pill/game */
  .pill {
    display:inline-flex;
    align-items:center;
    gap:12px;
    padding:6px 12px;
    min-height: calc(var(--bar-h) - 14px);
    background: var(--pill-bg);
    border-left: 3px solid var(--pill-border);
    border-radius:3px;
    color: #fff;
    font-weight:700;
    box-sizing:border-box;
    transition: box-shadow 200ms ease;
  }

  .pill .team {
    display:inline-flex; align-items:center; gap:8px; text-transform:uppercase;
    font-size: calc(var(--bar-h) * 0.28);
  }

  .pill img.logo {
    width: var(--logo-size);
    height: var(--logo-size);
    object-fit: contain;
    display:block;
  }

  .pill .score {
    display:flex; flex-direction:column; align-items:center; justify-content:center;
    font-variant-numeric: tabular-nums;
    line-height:1;
  }
  .pill .score .main { font-size: calc(var(--bar-h) * 0.28); font-weight:900; }
  .pill .score .sub { font-size: calc(var(--bar-h) * 0.16); opacity:0.92; text-transform:uppercase; }

  .pill .status {
    margin-left:10px;
    font-size: calc(var(--bar-h) * 0.18);
    opacity:0.9;
    white-space:nowrap;
  }

  /* FINAL red bug */
  .pill .final {
    margin-left:8px;
    padding:3px 7px;
    background: var(--espn-red);
    color:white;
    font-weight:900;
    font-size: calc(var(--bar-h) * 0.16);
    border-radius:3px;
  }

  /* separator (small dash) */
  .pill .sep { color: rgba(255,255,255,0.72); font-weight:900; margin: 0 4px; }

  /* subtle flash when score changes */
  .pill.score-flash {
    box-shadow: 0 6px 18px rgba(0,0,0,0.45), 0 0 14px rgba(255,255,255,0.04) inset;
    animation: scorePop 900ms ease;
  }
  @keyframes scorePop {
    0% { transform: scale(1.02); background: rgba(255,255,255,0.14); }
    40% { transform: scale(1.00); background: var(--pill-bg); }
    100% { transform: scale(1); background: var(--pill-bg); }
  }

  /* if logo fails, hide gracefully */
  img.logo[hidden] { display:none; }

  /* reduced motion */
  @media (prefers-reduced-motion: reduce) {
    .rail { transition: none !important; animation: none !important; }
  }
</style>
</head>
<body>
  <div class="ticker-wrap" id="tickerWrap" aria-live="polite">
    <div class="rail-viewport">
      <div class="rail" id="rail"></div>
    </div>
  </div>

<script>
/* ===========================
   Config
   =========================== */
const TARGET_LOOP_SECONDS = 36; // ESPN-like full loop target (you can adjust)
const MIN_PADDING = 600;        // minimum extra blank px to pad to ensure movement
const REFRESH_MS = 45_000;      // fetch every 45s
const LEAGUES = [
  { name: "NFL", url: "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard" },
  { name: "NBA", url: "https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard" },
  { name: "MLB", url: "https://site.api.espn.com/apis/site/v2/sports/baseball/mlb/scoreboard" },
  { name: "NHL", url: "https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard" }
];
const CACHE_TTL = 30_000;

/* ===========================
   Helpers: safe, PST conversions, fetch with fallback
   =========================== */
function safe(o, p, f = "") {
  try { return p.split(".").reduce((x, k) => (x && x[k] !== undefined ? x[k] : undefined), o) ?? f; }
  catch { return f; }
}

async function fetchJson(url) {
  try {
    const r = await fetch(url, { cache: "no-store" });
    if (r.ok) return r.json();
  } catch (e) { /* ignore */ }
  try {
    const r2 = await fetch("https://api.allorigins.win/raw?url=" + encodeURIComponent(url));
    if (r2.ok) return r2.json();
  } catch (e) { /* ignore */ }
  return null;
}

function pstTimestamp(iso) {
  try {
    if (!iso) return 0;
    const d = new Date(iso);
    const local = new Date(d.toLocaleString("en-US", { timeZone: "America/Los_Angeles" }));
    return local.getTime();
  } catch { return 0; }
}

function formatPST(iso) {
  try {
    if (!iso) return "";
    const d = new Date(iso);
    const local = new Date(d.toLocaleString("en-US", { timeZone: "America/Los_Angeles" }));
    return local.toLocaleString("en-US", { month: "numeric", day: "numeric", hour: "numeric", minute: "2-digit", hour12: true }).replace(",", "");
  } catch { return ""; }
}

/* ===========================
   Data fetch & assemble
   =========================== */
let CACHE = null, CACHE_TS = 0;

async function fetchScores() {
  const now = Date.now();
  if (CACHE && (now - CACHE_TS) < CACHE_TTL) return CACHE;

  const segments = [];
  const playoffGroups = {};

  for (const lg of LEAGUES) {
    try {
      const data = await fetchJson(lg.url);
      if (!data) continue;

      const events = (data.events || []).slice();
      for (const ev of events) {
        const comp = safe(ev, "competitions.0", null);
        if (!comp) continue;
        const away = (comp.competitors || []).find(t => t.homeAway === "away");
        const home = (comp.competitors || []).find(t => t.homeAway === "home");
        if (!away || !home) continue;

        const iso = ev.date || comp.date || "";
        const kickoff = iso ? formatPST(iso) : "";

        const status = safe(comp, "status.type", {});
        const state = safe(status, "state", "");
        const isLive = state === "in";
        const statusText = isLive ? "LIVE" : (safe(status, "shortDetail", "") || safe(status, "type.text", "") || "");
        const statusDetail = (safe(status, "type.detail", "") || "").toUpperCase();

        const broadcasts = safe(comp, "broadcasts", []) || safe(ev, "broadcasts", []) || [];
        let network = "";
        if (Array.isArray(broadcasts) && broadcasts.length) {
          const b = broadcasts.find(b => b.market === "national") || broadcasts[0];
          if (b) {
            if (Array.isArray(b.names)) network = b.names.slice(0, 3).join(", ");
            else if (b.name) network = b.name;
          }
        }

        const awayLogo = safe(away, "team.logo", safe(away, "team.logos.0.href", "")) || "";
        const homeLogo = safe(home, "team.logo", safe(home, "team.logos.0.href", "")) || "";
        const awayAbbr = (safe(away, "team.abbreviation", safe(away, "team.displayName", "")) || "").toUpperCase();
        const homeAbbr = (safe(home, "team.abbreviation", safe(home, "team.displayName", "")) || "").toUpperCase();
        const awayScore = safe(away, "score", "");
        const homeScore = safe(home, "score", "");
        const isPlayoff = safe(ev, "season.type", 0) === 3;
        const round = isPlayoff ? safe(comp, "notes.0.headline", safe(ev, "league.name", "Playoffs")) : "";

        const item = {
          league: lg.name,
          isPlayoff,
          round,
          iso,
          kickoff,
          network,
          away: { abbr: awayAbbr, logo: awayLogo, score: awayScore },
          home: { abbr: homeAbbr, logo: homeLogo, score: homeScore },
          isLive,
          statusText,
          statusDetail
        };

        if (isPlayoff) {
          playoffGroups[round] = playoffGroups[round] || [];
          playoffGroups[round].push(item);
        } else {
          segments.push(item);
        }
      }
    } catch (err) {
      console.error("League fetch error", lg.name, err);
    }
  }

  // combine playoff groups then regulars
  const result = [];
  const rounds = Object.keys(playoffGroups).sort();
  for (const r of rounds) {
    const arr = playoffGroups[r].sort((a,b) => pstTimestamp(a.iso) - pstTimestamp(b.iso));
    result.push({ type: 'roundHeader', header: r });
    result.push(...arr);
  }
  const regularSorted = segments.sort((a,b) => pstTimestamp(a.iso) - pstTimestamp(b.iso));
  if (regularSorted.length) {
    result.push({ type: 'roundHeader', header: 'Regular' });
    result.push(...regularSorted);
  }

  // dedupe by iso/away/home
  const seen = new Set(); const dedup = [];
  for (const it of result) {
    if (it.type === 'roundHeader') { dedup.push(it); continue; }
    const key = `${it.iso}|${it.away.abbr}|${it.home.abbr}`;
    if (!seen.has(key)) { seen.add(key); dedup.push(it); }
  }

  CACHE = dedup; CACHE_TS = Date.now();
  return dedup;
}

/* ===========================
   Rendering (DOM) helpers & flash detection
   =========================== */

const rail = document.getElementById('rail');
let previousScoreMap = new Map(); // key -> "away-home" -> "A-B"

function scoreKey(item) {
  return `${item.away.abbr}|${item.home.abbr}|${item.iso || ''}`;
}

/* create pill node for a single item */
function createPill(item) {
  const pill = document.createElement('span');
  pill.className = 'pill';
  pill.dataset.key = scoreKey(item);

  // away team
  const away = document.createElement('span'); away.className = 'team';
  const aLogo = document.createElement('img'); aLogo.className = 'logo'; aLogo.src = item.away.logo || ''; aLogo.alt = item.away.abbr || '';
  aLogo.onerror = () => aLogo.hidden = true;
  away.appendChild(aLogo);
  const aText = document.createElement('span'); aText.textContent = item.away.abbr || '';
  away.appendChild(aText);
  pill.appendChild(away);

  // separator dash & score
  const score = document.createElement('span'); score.className = 'score';
  const main = document.createElement('span'); main.className = 'main'; main.textContent = `${item.away.score || '-'} – ${item.home.score || '-'}`;
  score.appendChild(main);
  const sub = document.createElement('span'); sub.className = 'sub';
  // use kickoff if not live and not final
  if (item.isLive) sub.textContent = item.statusText || 'LIVE';
  else sub.textContent = item.kickoff || item.statusText || item.network || '';
  score.appendChild(sub);
  pill.appendChild(score);

  // home
  const home = document.createElement('span'); home.className = 'team';
  const hText = document.createElement('span'); hText.textContent = item.home.abbr || '';
  home.appendChild(hText);
  const hLogo = document.createElement('img'); hLogo.className = 'logo'; hLogo.src = item.home.logo || ''; hLogo.alt = item.home.abbr || '';
  hLogo.onerror = () => hLogo.hidden = true;
  home.appendChild(hLogo);
  pill.appendChild(home);

  // final bug
  if (!item.isLive && (item.statusText||'').toUpperCase().includes('FINAL')) {
    const f = document.createElement('span'); f.className = 'final'; f.textContent = 'FINAL';
    pill.appendChild(f);
  }

  return pill;
}

/* assemble rail from list (no league headers per user) */
function buildRailFragment(list) {
  const frag = document.createDocumentFragment();
  for (const it of list) {
    if (it.type === 'roundHeader') continue; // skip league/round headers per latest ask
    const p = createPill(it);
    frag.appendChild(p);
  }
  return frag;
}

/* update previousScoreMap and return keys that changed scores */
function detectScoreChanges(list) {
  const changedKeys = [];
  const newMap = new Map();
  for (const it of list) {
    if (it.type === 'roundHeader') continue;
    const k = scoreKey(it);
    const scoreStr = `${it.away.score || '-'}-${it.home.score || '-'}`;
    newMap.set(k, scoreStr);
    const old = previousScoreMap.get(k);
    if (old && old !== scoreStr) changedKeys.push(k);
  }
  previousScoreMap = newMap;
  return changedKeys;
}

/* ===========================
   Scrolling engine (seamless duplication + adaptive speed)
   =========================== */

let raf = null;
let lastTs = null;
let x = 0; // current translateX (px)
let railWidth = 0;
let viewportWidth = 0;
let speedPxPerSec = 0;

function stopScroll() {
  if (raf) cancelAnimationFrame(raf);
  raf = null;
  lastTs = null;
}

function startScrollLoop() {
  stopScroll();
  // measure
  viewportWidth = document.querySelector('.rail-viewport').clientWidth;
  // railWidth should be width of one copy
  const single = document.querySelector('.rail .pill') ? measureSingleRailWidth() : 0;
  railWidth = measureRailWidth(); // total width of single rail content (we'll duplicate)
  if (railWidth <= 0) return;

  // Add padding so even short rails scroll well
  const pad = Math.max(MIN_PADDING, Math.round(viewportWidth * 0.4));
  // We'll append an empty spacer element at end of first rail to pad loop
  const spacer = document.createElement('span');
  spacer.style.display = 'inline-block';
  spacer.style.width = pad + 'px';
  spacer.className = 'loop-spacer';
  document.querySelector('.rail').appendChild(spacer);

  // recompute after pad
  railWidth = measureRailWidth();

  // compute adaptive px/sec so that (railWidth + viewportWidth) / speed ≈ TARGET_LOOP_SECONDS
  speedPxPerSec = Math.max(60, (railWidth + viewportWidth) / Math.max(8, TARGET_LOOP_SECONDS));
  // ensure not too slow/fast
  speedPxPerSec = Math.min(Math.max(speedPxPerSec, 70), 220);

  // duplicate rail contents for seamless wrap (if not already duplicated)
  ensureRailDuplicated();

  x = 0; lastTs = null;

  function frame(ts) {
    if (!lastTs) lastTs = ts;
    const dt = (ts - lastTs) / 1000;
    lastTs = ts;

    x -= speedPxPerSec * dt;

    // when x <= -railWidth, wrap by adding railWidth
    if (Math.abs(x) >= railWidth) {
      x += railWidth;
    }

    rail.style.transform = `translateX(${x}px)`;
    raf = requestAnimationFrame(frame);
  }

  raf = requestAnimationFrame(frame);
}

/* measure rail single width (content before duplication) */
function measureRailWidth() {
  // measure the width of the first copy (stop at the first .loop-spacer if present)
  const children = Array.from(rail.children);
  if (children.length === 0) return 0;
  // If we previously duplicated, children contains two copies. We'll measure first group's width by summing until halfway where duplicate starts.
  // Simpler: wrap rail content in a temporary container clone and measure its scrollWidth.
  // Create a clone of first rail with same children until midpoint
  const clone = rail.cloneNode(true);
  // remove trailing duplicate if any duplicate marker exists (we use .duplicated flag)
  const firstWidth = clone.scrollWidth;
  return firstWidth;
}

function measureSingleRailWidth() {
  return measureRailWidth();
}

/* ensure we have duplicated content so we can wrap seamlessly */
function ensureRailDuplicated() {
  // If rail has children duplicated (we check data attribute), ensure it is duplicated once.
  if (!rail.dataset.duplicated) {
    // clone current children into an appended copy
    const frag = document.createDocumentFragment();
    const children = Array.from(rail.children);
    for (const c of children) {
      frag.appendChild(c.cloneNode(true));
    }
    rail.appendChild(frag);
    rail.dataset.duplicated = "1";
  }
}

/* clear duplicate and rebuild when content changes */
function rebuildRail(list) {
  stopScroll();
  // clear
  rail.innerHTML = '';
  rail.dataset.duplicated = '';
  // build fragment for single rail
  const frag = buildRailFragment(list);
  rail.appendChild(frag);
  // do not duplicate here; startScrollLoop will duplicate
}

/* ===========================
   Update loop: fetch -> detect changes -> flash -> rebuild -> restart scroll
   =========================== */

async function updateAndRun() {
  try {
    const list = await fetchScores();
    // detect score changes before we rebuild (previousScoreMap contains last loop's values)
    const changedKeys = detectScoreChanges(list);

    // rebuild rail with new items (no headers per user)
    rebuildRail(list);

    // after building, if there were changed keys, temporarily mark pills
    if (changedKeys.length) {
      for (const key of changedKeys) {
        const pill = rail.querySelector(`.pill[data-key="${cssEscape(key)}"]`);
        if (pill) {
          pill.classList.add('score-flash');
          setTimeout(() => pill.classList.remove('score-flash'), 1100);
        }
      }
    }

    // start scrolling
    // small delay to ensure DOM paints
    setTimeout(startScrollLoop, 80);
  } catch (err) {
    console.error('updateAndRun error', err);
  }
}

/* simple css escape for attribute selection */
function cssEscape(str) {
  return String(str).replace(/["\\]/g, '\\$&');
}

/* bootstrap */
updateAndRun();
setInterval(updateAndRun, REFRESH_MS);

</script>
</body>
</html>
