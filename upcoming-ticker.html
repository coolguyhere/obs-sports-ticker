<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Top Games This Week</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  background: transparent;
  overflow: hidden;
  font-family: Arial, Helvetica, sans-serif;
}

/* Top bar wrapper */
.ticker-wrap {
  position: fixed;
  top: 0;
  width: 100%;
  height: 80px;
  background: rgba(0,0,0,0.35);
  display: flex;
  align-items: center;
  overflow: hidden;
  transition: opacity 0.8s ease;
}

.ticker-wrap.hidden {
  opacity: 0;
  pointer-events: none;
}

/* Left label */
.ticker-label {
  flex: 0 0 auto;
  padding: 0 18px;
  font-size: 22px;
  font-weight: bold;
  color: #ffffff;
  text-transform: uppercase;
  border-right: 2px solid rgba(255,255,255,0.3);
}

/* Scrolling area */
.ticker {
  flex: 1 1 auto;
  white-space: nowrap;
  padding-left: 100%;
  font-size: 22px;
  color: #ffffff;
  opacity: 0;
}

.scroll {
  animation:
    fadeIn 1.5s ease forwards,
    scroll 70s linear forwards,
    fadeOut 1.5s ease forwards;
  animation-delay: 0s, 0s, 68.5s;
}

@keyframes scroll {
  from { transform: translateX(0); }
  to   { transform: translateX(-100%); }
}

@keyframes fadeIn {
  from { opacity: 0; }
  to   { opacity: 1; }
}

@keyframes fadeOut {
  from { opacity: 1; }
  to   { opacity: 0; }
}

.separator {
  margin: 0 18px;
  color: #ffffff;
}

/* Game pill styling */
.game-pill {
  display: inline-flex;
  align-items: center;
  border-radius: 999px;
  padding: 6px 12px;
}

.game-pill img {
  height: 22px;
  width: 22px;
  object-fit: contain;
}

.game-meta {
  font-size: 14px;
  opacity: 0.9;
  margin-left: 8px;
}
</style>
</head>
<body>

<div class="ticker-wrap" id="tickerWrap">
  <div class="ticker-label">Top Games This Week</div>
  <div class="ticker" id="ticker">Loading upcoming games…</div>
</div>

<script>
// ---------------- CONFIG ----------------

const PROXY = "https://api.allorigins.win/raw?url=";

const leagues = [
  {
    code: "NFL",
    scoreboard: "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard",
    calendar:   "https://site.api.espn.com/apis/site/v2/sports/football/nfl/scoreboard?calendar=true"
  },
  {
    code: "NBA",
    scoreboard: "https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard",
    calendar:   "https://site.api.espn.com/apis/site/v2/sports/basketball/nba/scoreboard?calendar=true"
  },
  {
    code: "MLB",
    scoreboard: "https://site.api.espn.com/apis/site/v2/sports/baseball/mlb/scoreboard",
    calendar:   "https://site.api.espn.com/apis/site/v2/sports/baseball/mlb/scoreboard?calendar=true"
  },
  {
    code: "NHL",
    scoreboard: "https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard",
    calendar:   "https://site.api.espn.com/apis/site/v2/sports/hockey/nhl/scoreboard?calendar=true"
  }
];

const leagueColors = {
  NFL: "#013369",
  NBA: "#17408B",
  MLB: "#002D72",
  NHL: "#111111"
};

const TOP_N = 5;

// animation / timing
const SCROLL_DURATION = 70000;          // match your existing 70s scroll
const LOOP_PAUSE = 1500;                // 1.5s pause between loops
const REFRESH_INTERVAL = 10 * 60 * 1000; // 10 minutes

let loopTimeout = null;
let refreshIntervalId = null;

// ---------------- HELPERS ----------------

function formatPST(iso) {
  try {
    const d = new Date(iso);
    return d.toLocaleString("en-US", {
      timeZone: "America/Los_Angeles",
      weekday: "short",
      hour: "numeric",
      minute: "2-digit"
    });
  } catch {
    return "";
  }
}

function winPct(team) {
  if (!team.records) return 0.5;
  const rec = team.records.find(r => r.type === "total") || team.records[0];
  if (!rec || !rec.summary) return 0.5;
  const parts = rec.summary.split("-");
  if (parts.length < 2) return 0.5;
  const w = parseInt(parts[0], 10);
  const l = parseInt(parts[1], 10);
  if (w + l === 0) return 0.5;
  return w / (w + l);
}

function anticipation(a, b) {
  const avg = (a + b) / 2;
  const diff = Math.abs(a - b);
  return avg - diff;
}

// ---------------- CALENDAR FETCH ----------------

async function getNextCalendarDates(league) {
  try {
    const url = PROXY + encodeURIComponent(league.calendar);
    const res = await fetch(url);
    const data = await res.json();

    if (!data.calendar) return [];

    const future = [];

    for (const block of data.calendar) {
      for (const entry of block.entries) {
        if (entry.startDate) {
          const d = entry.startDate.substring(0, 10).replace(/-/g, "");
          future.push(d);
        }
      }
    }

    return [...new Set(future)].slice(0, 12);
  } catch {
    return [];
  }
}

// ---------------- FETCH GAMES ----------------

async function fetchGames() {
  let playoffGames = [];
  let regularGames = [];

  for (const league of leagues) {
    const dates = await getNextCalendarDates(league);
    if (!dates.length) continue;

    for (const date of dates) {
      try {
        const url = PROXY + encodeURIComponent(`${league.scoreboard}?dates=${date}`);
        const res = await fetch(url);
        const data = await res.json();
        const events = data.events || [];

        for (const ev of events) {
          const comp = ev.competitions?.[0];
          if (!comp) continue;

          const seasonType = comp.season?.type;

          // Only competitive games (2, 3, 4 style logic)
          if (![2, 3].includes(seasonType)) continue;

          const teams = comp.competitors || [];
          const away = teams.find(t => t.homeAway === "away");
          const home = teams.find(t => t.homeAway === "home");
          if (!away || !home) continue;

          const aStr = winPct(away);
          const hStr = winPct(home);
          const score = anticipation(aStr, hStr);

          const game = {
            league: league.code,
            away,
            home,
            score,
            rawDate: ev.date,
            pst: formatPST(ev.date),
            playoff: seasonType === 3,
            playoffRound: comp.notes?.[0]?.headline || "Playoffs"
          };

          if (game.playoff) playoffGames.push(game);
          else regularGames.push(game);
        }
      } catch {
        // ignore individual fetch failures and keep going
      }
    }
  }

  // sort playoff games by soonest date, then anticipation
  playoffGames.sort((a, b) => {
    const d = new Date(a.rawDate) - new Date(b.rawDate);
    if (d !== 0) return d;
    return b.score - a.score;
  });

  // sort regular games by anticipation score then date
  regularGames.sort((a, b) => {
    const s = b.score - a.score;
    if (s !== 0) return s;
    return new Date(a.rawDate) - new Date(b.rawDate);
  });

  const combined = [...playoffGames, ...regularGames];
  return combined.slice(0, TOP_N);
}

// ---------------- RENDER & LOOP ----------------

function buildHTML(games) {
  return games.map(g => {
    const lc = leagueColors[g.league] || "#222";
    const aAbbr = g.away.team?.abbreviation || "";
    const hAbbr = g.home.team?.abbreviation || "";
    const aLogo = g.away.team?.logo;
    const hLogo = g.home.team?.logo;
    const aRec = g.away.records?.[0]?.summary || "";
    const hRec = g.home.records?.[0]?.summary || "";

    const playoffTag = g.playoff
      ? `<span class="game-meta">${g.league} • ${g.playoffRound} • ${g.pst}</span>`
      : `<span class="game-meta">${g.league} • ${g.pst}</span>`;

    return `
      <span class="game-pill" style="background:${lc};">
        ${aLogo ? `<img src="${aLogo}" style="margin-right:6px;">` : ""}
        ${aAbbr}${aRec ? ` (${aRec})` : ""}
        <span style="margin:0 8px;">vs</span>
        ${hAbbr}${hRec ? ` (${hRec})` : ""}
        ${hLogo ? `<img src="${hLogo}" style="margin-left:6px;">` : ""}
        ${playoffTag}
      </span>
    `;
  }).join(`<span class="separator">|</span>`);
}

function startLoop() {
  const ticker = document.getElementById("ticker");
  if (!ticker) return;

  // clear any existing loop timer
  if (loopTimeout) {
    clearTimeout(loopTimeout);
    loopTimeout = null;
  }

  // reset animation
  ticker.style.animation = "none";
  // ensure opacity 1 before fade-in
  ticker.style.opacity = "0";

  // force reflow
  void ticker.offsetWidth;

  // quick fade-in + scroll (no fadeOut)
  const scrollSeconds = SCROLL_DURATION / 1000;
  ticker.style.animation = `fadeIn 0.4s ease forwards, scroll ${scrollSeconds}s linear forwards`;

  // schedule next loop after scroll + pause
  loopTimeout = setTimeout(() => {
    startLoop();
  }, SCROLL_DURATION + LOOP_PAUSE);
}

function render(games, isRefresh = false) {
  const wrap = document.getElementById("tickerWrap");
  const ticker = document.getElementById("ticker");
  if (!wrap || !ticker) return;

  // never fully hide the bar; show a fallback message if no games
  if (!games.length) {
    wrap.classList.remove("hidden");
    ticker.className = "ticker";
    ticker.style.animation = "none";
    ticker.style.opacity = "1";
    ticker.innerHTML = "No top upcoming games found.";
    return;
  }

  const newHTML = buildHTML(games);

  // crossfade on refresh: fade out, swap content, fade in + restart loop
  if (isRefresh) {
    wrap.classList.add("hidden"); // uses existing opacity transition
    setTimeout(() => {
      ticker.className = "ticker";
      ticker.innerHTML = newHTML;
      wrap.classList.remove("hidden");
      startLoop();
    }, 800); // matches .ticker-wrap transition: 0.8s
  } else {
    wrap.classList.remove("hidden");
    ticker.className = "ticker";
    ticker.innerHTML = newHTML;
    startLoop();
  }
}

// ---------------- MAIN LOOP ----------------

async function run(isRefresh = false) {
  try {
    const games = await fetchGames();
    render(games, isRefresh);
  } catch {
    // if fetch fails, keep whatever is currently on screen
  }
}

function init() {
  // initial load
  run(false);

  // periodic refresh every 10 minutes
  if (refreshIntervalId) {
    clearInterval(refreshIntervalId);
  }
  refreshIntervalId = setInterval(() => {
    run(true);
  }, REFRESH_INTERVAL);
}

init();
</script>
</body>
</html>
